# Head First Design Patterns

## 개요
Practice and description design patterns using Java
## 목차
### 객체지향 원칙
### 1. Strategy Pattern
### 2. Observer Pattern
### 3. Decorator Pattern
### 4. Factory pattern
***
***
### 객체지향 원칙
-	바뀌는 부분은 캡슐화한다.
-	상속보다는 구성을 활용한다.
-	구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.
-	서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.
-	클래스는 확장에 대해서는 열려 있지만 변경에 대해서는 닫혀 있어야 한다.
-	추상화된 것에 의존하라. 구상 클래스에 의존하지 않도록 한다.
***
### 1. Strategy Pattern
##### 스트래티지 패턴 (Strategy Pattern)
스트래티지 패턴에서는 알고리즘군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다. 스트래티지를 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.
##### 디자인 원칙
애플리케이션에서 달라지는 부분을 찾아내고 달라지지 않는 부분으로부터 분리시킨다.  
바뀌는 부분은 따로 뽑아서 캡슐화시킨다. 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치거나 확장할 수 있다.  
상속보다는 구성을 이용한다.   
구현이 아닌 인터페이스(상위형식)에 맞춰서 프로그래밍한다.
*	구현에 맞춰서 프로그래밍 (X)  
 Dog d = new Dog(); 
d.bark();
*	인터페이스/상위형식에 맞춰서 프로그래밍 (Δ)  
 Animal animal = new Dog(); 
animal.makeSound();
*	구체적으로 구현된 객체를 실행시에 대입 (O)  
 a = getAnimal();
 a.makeSound();
##### 객체지향의 기초
추상화  
캡슐화  
다형성  
상속
##### 객체지향 원칙
바뀌는 부분은 캡슐화한다.  
상속보다는 구성을 활용한다.  
구현이 아닌 인터페이스에 맞춰서 프로그래밍 한다.
***
### 3. Decorator Pattern

##### 데코레이터 패턴(Decorator Pattern)
객체에 추가적인 요건을 동적으로 첨가한다. 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.

##### OCP(Open-Closed Principle)
(데코레이터 패턴은 OCP에 충실)  
: 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다.  
무조건 OCP를 적용하면 오히려 불필요하게 복잡하고 이해하기 힘든 코드만 만들게 되는 부작용이 있을 수 있다.  코드가 바뀔 가능성이 있는 부분을 잘 뽑아내서 OCP를 준수한다.

##### 핵심정리
구성과 위임을 통해서 실행중에 새로운 행동을 추가할 수 있다.  
상속 대신 데코레이터 패턴을 통해서 행동을 확장할 수 있다.  
데코레이터 패턴에서는 구상 구성요소를 감싸주는 데코레이터를 사용한다.  
데코레이터 클래스의 형식은 그 클래스가 감싸고 있는 클래스의 형식을 반영한다. (상속 또는 인터페이스 구현을 통해서 자신이 감쌀 클래스와 같은 형식을 가지게 된다.)  
데코레이터에서는 자기가 감싸고 있는 구성요소의 메소드를 호출한 결과에 새로운 기능을 더함으로써 행동을 확장한다.  
구성요소를 감싸는 데코레이터의 개수제한은 없다.  
구성요소의 클라이언트 입장에서는 데코레이터의 존재를 알 수 없다. (클라이언트에서 구성요소의 구체적인 형식에 의존하게 되는 경우 예외)  
Java.io.API 문서도 데코레이터 패턴으로 구성  
데코레이터 패턴을 이용해서 디자인하다 보면 잡다한 클래스들이 너무 많아진다. 하지만 데코레이터가 어떤 식으로 작동하는지 이해하고 나면, 다른 사람이 데코레이터 패턴을 활용해서 만든 API를 쓰더라도 클래스들이 어떤 식으로 구성되어 있는지 일단 파악하고 나면 클래스를 데코레이터로 감싸서 원하는 행동을 구현할 수 있다.  
객체지향 원칙 : 클래스는 확장에 대해서는 열려 있지만 변경에 대해서는 닫혀 있어야 한다.  



